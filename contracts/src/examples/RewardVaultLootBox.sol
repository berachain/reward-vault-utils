// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {RewardVaultEntropy} from "../core/RewardVaultEntropy.sol";
import {ERC721} from "@solmate/tokens/ERC721.sol";
import {ERC20} from "@solmate/tokens/ERC20.sol";

/// @title RewardVaultLootBox
/// @notice A loot box system that uses Pyth Entropy for random rewards and mints ERC-721 tokens
/// @dev Extends RewardVaultEntropy and implements ERC-721 for loot box NFTs
contract RewardVaultLootBox is RewardVaultEntropy, ERC721 {
    /// @notice Loot box rarity levels
    enum Rarity {
        COMMON,
        UNCOMMON,
        RARE,
        EPIC,
        LEGENDARY
    }

    /// @notice Loot box item structure
    struct LootBoxItem {
        uint256 tokenId;
        Rarity rarity;
        uint256 rewardBips; // Reward amount in basis points
        address rewardToken;
        bool claimed;
        uint256 mintedAt;
    }

    /// @notice Maps token IDs to loot box items
    mapping(uint256 => LootBoxItem) public lootBoxItems;

    /// @notice Maps sequence numbers to pending loot box opens
    mapping(uint64 => PendingLootBox) public pendingLootBoxes;

    /// @notice Current token ID counter
    uint256 public nextTokenId;

    /// @notice Base URI for token metadata
    string public baseURI;

    /// @notice Rarity probabilities (in basis points, 10000 = 100%)
    mapping(Rarity => uint256) public rarityProbabilities;

    /// @notice Reward amounts in basis points (bips) for each rarity
    mapping(Rarity => uint256) public rarityRewardBips;

    /// @notice Struct for pending loot box opens
    struct PendingLootBox {
        address opener;
        uint256 timestamp;
        bool processed;
    }

    /// @notice Emitted when a loot box opening is initiated
    /// @param opener The address that initiated the loot box opening
    /// @param sequenceNumber The entropy sequence number
    event LootBoxOpeningInitiated(address indexed opener, uint64 indexed sequenceNumber);

    /// @notice Emitted when a loot box is opened and NFT is minted
    /// @param tokenId The token ID of the loot box
    /// @param opener The address that opened the loot box
    /// @param sequenceNumber The entropy sequence number
    /// @param rarity The rarity of the loot box
    /// @param rewardBips The reward amount in basis points
    event LootBoxOpened(
        uint256 indexed tokenId,
        address indexed opener,
        uint64 indexed sequenceNumber,
        Rarity rarity,
        uint256 rewardBips
    );

    /// @notice Emitted when a loot box item is claimed
    /// @param tokenId The token ID of the loot box
    /// @param owner The owner of the loot box
    /// @param rewardAmount The amount of rewards claimed
    /// @param rewardToken The token address of the rewards
    event LootBoxClaimed(uint256 indexed tokenId, address indexed owner, uint256 rewardAmount, address rewardToken);

    /// @notice Custom errors
    error InvalidRarity();
    error LootBoxNotMinted();
    error LootBoxAlreadyClaimed();
    error InvalidProbabilities();
    error InvalidRewardBips();
    error NotLootBoxOwner();
    error InsufficientLiquidBGTBalance();

    /// @notice Creates a new RewardVaultLootBox
    /// @param _entropyContract The address of the Pyth Entropy contract
    /// @param _name The name of the ERC-721 token
    /// @param _symbol The symbol of the ERC-721 token
    /// @param _baseURI The base URI for token metadata
    constructor(address _entropyContract, string memory _name, string memory _symbol, string memory _baseURI)
        RewardVaultEntropy(_entropyContract)
        ERC721(_name, _symbol)
    {
        baseURI = _baseURI;
        _initializeRarityProbabilities();
        _initializeRarityRewardBips();
    }

    /// @notice Open a loot box using entropy
    /// @param provider The entropy provider address
    /// @param userRandomNumber A secret random number generated by the user
    /// @return sequenceNumber The sequence number for the entropy request
    function openLootBox(address provider, bytes32 userRandomNumber) external payable returns (uint64 sequenceNumber) {
        // Request entropy with callback data containing the opener's address
        bytes memory callbackData = abi.encode(msg.sender);
        // trusted: Pyth Entropy contract
        sequenceNumber = this.requestEntropyWithCallback{value: msg.value}(provider, userRandomNumber, callbackData);

        // Store pending loot box information
        pendingLootBoxes[sequenceNumber] =
            PendingLootBox({opener: msg.sender, timestamp: block.timestamp, processed: false});

        emit LootBoxOpeningInitiated(msg.sender, sequenceNumber);
    }

    /// @notice Process entropy callback and mint loot box NFT
    /// @param sequence The sequence number for the entropy request
    /// @param provider The entropy provider address (unused but required by interface)
    /// @param randomNumber The random number from Pyth Entropy
    /// @param callback The callback data associated with the request
    function _processEntropy(
        uint64 sequence,
        address provider,
        bytes32 randomNumber,
        EntropyCallbackData memory callback
    ) internal virtual override {
        // Use provider to silence linter warning
        provider;
        // Decode the opener's address from callback data
        address opener = abi.decode(callback.data, (address));

        // Verify this is a pending loot box
        PendingLootBox storage pending = pendingLootBoxes[sequence];
        require(pending.opener == opener, "Invalid opener");
        require(!pending.processed, "Already processed");

        // Mark as processed
        pending.processed = true;

        // Generate loot box item based on random number
        LootBoxItem memory item = _generateLootBoxItem(randomNumber);

        // Mint the NFT to the opener
        uint256 tokenId = nextTokenId++;
        _mint(opener, tokenId);

        // Store the loot box item
        lootBoxItems[tokenId] = item;

        emit LootBoxOpened(tokenId, opener, sequence, item.rarity, rarityRewardBips[item.rarity]);
    }

    /// @notice Claim rewards from a loot box
    /// @param tokenId The token ID of the loot box
    function claimLootBox(uint256 tokenId) external {
        LootBoxItem storage item = lootBoxItems[tokenId];
        if (item.tokenId == 0) revert LootBoxNotMinted();
        if (item.claimed) revert LootBoxAlreadyClaimed();
        if (ownerOf(tokenId) != msg.sender) revert NotLootBoxOwner();

        // Mark as claimed
        item.claimed = true;

        // Transfer rewards if any
        if (item.rewardBips > 0 && item.rewardToken != address(0)) {
            // trusted: ERC20 token contract
            ERC20(item.rewardToken).transfer(msg.sender, _calculateRewardAmount(item.rarity, item.rewardBips));
        }

        emit LootBoxClaimed(tokenId, msg.sender, _calculateRewardAmount(item.rarity, item.rewardBips), item.rewardToken);
    }

    /// @notice Get loot box item details
    /// @param tokenId The token ID of the loot box
    /// @return The loot box item details
    function getLootBoxItem(uint256 tokenId) external view returns (LootBoxItem memory) {
        return lootBoxItems[tokenId];
    }

    /// @notice Get token URI for metadata
    /// @param id The token ID
    /// @return The token URI
    function tokenURI(uint256 id) public view virtual override returns (string memory) {
        if (ownerOf(id) == address(0)) revert LootBoxNotMinted();
        return string(abi.encodePacked(baseURI, _toString(id)));
    }

    /// @notice Set rarity probabilities
    /// @param rarities Array of rarity levels
    /// @param probabilities Array of probabilities in basis points
    function setRarityProbabilities(Rarity[] calldata rarities, uint256[] calldata probabilities) external onlyOwner {
        if (rarities.length != probabilities.length) revert InvalidProbabilities();

        uint256 totalProbability = 0;
        for (uint256 i = 0; i < rarities.length; i++) {
            rarityProbabilities[rarities[i]] = probabilities[i];
            totalProbability += probabilities[i];
        }

        if (totalProbability != 10000) revert InvalidProbabilities();
    }

    /// @notice Set rarity reward bips
    /// @param rarities Array of rarity levels
    /// @param bips Array of reward bips
    function setRarityRewardBips(Rarity[] calldata rarities, uint256[] calldata bips) external onlyOwner {
        if (rarities.length != bips.length) revert InvalidRewardBips();

        for (uint256 i = 0; i < rarities.length; i++) {
            rarityRewardBips[rarities[i]] = bips[i];
        }
    }

    /// @notice Set base URI for token metadata
    /// @param _baseURI The new base URI
    function setBaseURI(string memory _baseURI) external onlyOwner {
        baseURI = _baseURI;
    }

    /// @notice Initialize default rarity probabilities
    function _initializeRarityProbabilities() internal {
        rarityProbabilities[Rarity.COMMON] = 5000; // 50%
        rarityProbabilities[Rarity.UNCOMMON] = 3000; // 30%
        rarityProbabilities[Rarity.RARE] = 1500; // 15%
        rarityProbabilities[Rarity.EPIC] = 400; // 4%
        rarityProbabilities[Rarity.LEGENDARY] = 100; // 1%
    }

    /// @notice Initialize default rarity reward bips
    function _initializeRarityRewardBips() internal {
        rarityRewardBips[Rarity.COMMON] = 5000; // 50%
        rarityRewardBips[Rarity.UNCOMMON] = 3000; // 30%
        rarityRewardBips[Rarity.RARE] = 1500; // 15%
        rarityRewardBips[Rarity.EPIC] = 400; // 4%
        rarityRewardBips[Rarity.LEGENDARY] = 100; // 1%
    }

    /// @notice Generate a loot box item based on random number
    /// @param randomNumber The random number from entropy
    /// @return The generated loot box item
    function _generateLootBoxItem(bytes32 randomNumber) internal view returns (LootBoxItem memory) {
        // Use the random number to determine rarity following Pyth best practices
        Rarity rarity = _determineRarityFromEntropy(randomNumber);

        uint256 rewardBips = _calculateRewardBipsFromEntropy(rarity, randomNumber);

        return LootBoxItem({
            tokenId: nextTokenId,
            rarity: rarity,
            rewardBips: rewardBips,
            rewardToken: liquidBGTToken, // Use liquid BGT as default reward token
            claimed: false,
            mintedAt: block.timestamp
        });
    }

    /// @notice Determine rarity based on entropy following Pyth best practices
    /// @param entropy The entropy value from Pyth
    /// @return The determined rarity
    function _determineRarityFromEntropy(bytes32 entropy) internal view returns (Rarity) {
        // Use the first 16 bytes of entropy for rarity determination
        uint256 rarityRoll = uint256(entropy) % 10000;

        uint256 cumulative = 0;

        cumulative += rarityProbabilities[Rarity.COMMON];
        if (rarityRoll < cumulative) return Rarity.COMMON;

        cumulative += rarityProbabilities[Rarity.UNCOMMON];
        if (rarityRoll < cumulative) return Rarity.UNCOMMON;

        cumulative += rarityProbabilities[Rarity.RARE];
        if (rarityRoll < cumulative) return Rarity.RARE;

        cumulative += rarityProbabilities[Rarity.EPIC];
        if (rarityRoll < cumulative) return Rarity.EPIC;

        return Rarity.LEGENDARY;
    }

    /// @notice Calculate reward bips based on rarity and entropy following Pyth best practices
    /// @param rarity The rarity of the loot box
    /// @param entropy The entropy value from Pyth
    /// @return The calculated reward bips
    function _calculateRewardBipsFromEntropy(Rarity rarity, bytes32 entropy) internal view returns (uint256) {
        // Get the base reward bips for this rarity
        uint256 baseRewardBips = rarityRewardBips[rarity];

        // Use entropy for random factor calculation following Pyth best practices
        // Use different parts of entropy for different calculations to avoid bias
        uint256 randomFactor = _generateRandomFactorFromEntropy(entropy);

        // Apply random factor to base reward bips (80% to 120% of base reward)
        uint256 finalRewardBips = (baseRewardBips * randomFactor) / 10000;

        return finalRewardBips;
    }

    /// @notice Calculate the actual reward amount at claim time based on current contract balance
    /// @param rarity The rarity of the loot box (unused but kept for interface consistency)
    /// @param rewardBips The reward bips for the loot box
    /// @return The calculated reward amount in tokens
    function _calculateRewardAmount(Rarity rarity, uint256 rewardBips) internal view returns (uint256) {
        // Use rarity to silence linter warning
        rarity;
        // Get the available liquid BGT balance in this contract
        uint256 availableBalance = 0;
        if (liquidBGTToken != address(0)) {
            // trusted: ERC20 token contract
            availableBalance = ERC20(liquidBGTToken).balanceOf(address(this));
        }

        if (availableBalance == 0) return 0;

        // Calculate reward based on reward bips of available balance
        uint256 rewardAmount = (availableBalance * rewardBips) / 10000;

        return rewardAmount;
    }

    /// @notice Generate a random factor from entropy following Pyth best practices
    /// @param entropy The entropy value from Pyth
    /// @return Random factor between 8000 and 12000 (80% to 120%)
    function _generateRandomFactorFromEntropy(bytes32 entropy) internal pure returns (uint256) {
        // Use the middle 16 bytes of entropy for random factor
        // This avoids using the same bytes used for rarity determination
        uint256 entropyMiddle = uint256(entropy >> 64) & 0xFFFFFFFFFFFFFFFF;

        // Generate random factor between 8000 and 12000 (80% to 120%)
        uint256 randomRange = 4000; // 12000 - 8000
        uint256 randomOffset = entropyMiddle % randomRange;
        return 8000 + randomOffset;
    }

    /// @notice Determine rarity based on probability roll (deprecated - use _determineRarityFromEntropy)
    /// @param roll The probability roll (0-9999)
    /// @return The determined rarity
    function _determineRarity(uint256 roll) internal view returns (Rarity) {
        uint256 cumulative = 0;

        cumulative += rarityProbabilities[Rarity.COMMON];
        if (roll < cumulative) return Rarity.COMMON;

        cumulative += rarityProbabilities[Rarity.UNCOMMON];
        if (roll < cumulative) return Rarity.UNCOMMON;

        cumulative += rarityProbabilities[Rarity.RARE];
        if (roll < cumulative) return Rarity.RARE;

        cumulative += rarityProbabilities[Rarity.EPIC];
        if (roll < cumulative) return Rarity.EPIC;

        return Rarity.LEGENDARY;
    }

    /// @notice Convert uint256 to string
    /// @param value The value to convert
    /// @return The string representation
    function _toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) return "0";

        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }

        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }

        return string(buffer);
    }
}
